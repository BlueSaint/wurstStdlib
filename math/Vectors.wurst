package Vectors
	
	/*************************
	 ********3D-Vector********
	 *************************/
	public tuple vec3( real x, real y, real z )
	
	public function vec3.setLength( real length ) returns vec3
		real l = SquareRoot(this.x*this.x + this.y*this.y + this.z*this.z)
		if l == 0.0
			printError("vector.setLength error: The length of the vector is 0.0!")
			return vec3(0.,0.,0.)
        l = length/l
        return vec3(this.x*l, this.y*l, this.z*l)

	// op_ - Operator overloading
	public function vec3.op_plus( vec3 v )	returns vec3
		return vec3(this.x + v.x, this.y + v.y, this.z + v.z)
    
    public function vec3.op_minus( vec3 v )	returns vec3
		return vec3(this.x - v.x, this.y - v.y, this.z - v.z)
		
	public function vec3.op_mult(real factor) returns vec3
		return vec3(this.x*factor, this.y*factor, this.z*factor) 
                
    public function vec3.addVec2( vec2 v )	returns vec3
		return vec3(this.x + v.x, this.y + v.y, this.z)
        
    public function vec3.addReals( real x, real y, real z )	returns vec3
		return vec3(this.x + x, this.y + y, this.z + z)
	
    public function vec3.subVec2( vec2 v )	returns vec3
		return vec3(this.x - v.x, this.y - v.y, this.z)
        	
	public function vec3.scaleXY( real factor )	returns vec3
		return vec3(this.x * factor, this.y * factor, this.z)
		
	public function vec3.cross( vec3 v ) returns vec3
		return vec3( this.y*v.z-this.z*v.y, this.z*v.x-this.x*v.z, this.x*v.y-this.y*v.x ) 
		
	public function vec3.dot( vec3 v ) returns real
		return this.x*v.x + this.y*v.y + this.z*v.z
		        
    public function vec3.project( vec3 direction ) returns vec3
    	real l = direction.x*direction.x+direction.y*direction.y+direction.z*direction.z
        if l == 0.0
        	printError("vector.projectVector error: The length of the direction vector is 0.0!")
            return vec3(0.,0.,0.)
            
        l = (this.x*direction.x+this.y*direction.y+this.z*direction.z) / l
		return vec3( direction.x*l, direction.y*l, direction.z*l )
        
    public function vec3.norm() returns vec3
        real len = this.length()
        real x = 0 
        real y = 0
        real z = 0
        if (len != 0.0)
            x = (this.x / len)
            y = (this.y / len)
            z = (this.z / len)
        return vec3(x,y,z)
	

	public function vec3.trim( real value ) returns vec3
		vec3 result = this
		if result.x > -value and result.x < value
			result.x = 0.
		if result.y > -value and result.y < value
			result.y = 0.
		if result.z > -value and result.z < value
			result.z = 0.
		return result
        
    public function vec3.toVec2() returns vec2
        return vec2( this.x, this.y )		
		
	public function vec3.length() returns real
		return SquareRoot(this.x*this.x+this.y*this.y+this.z*this.z)
		
	public function vec3.lengthSquared() returns real
		return this.x*this.x+this.y*this.y+this.z*this.z
		
	public function vec3.lengthXY() returns real
		return SquareRoot(this.x*this.x+this.y*this.y)
			
	public function vec3.inCircle( vec3 v2, real radius ) returns boolean
		if (this.x-v2.x).squared() + (this.y-v2.y).squared() <= radius*radius
			return true
		return false
		
	public function vec3.toString() returns string
		return "Vector3 [ " + this.x.toString() + ", " + this.y.toString() + ", " + this.z.toString() + " ]"
		
	public function vec3.flat() returns vec2
		return vec2(this.x, this.y)
		
	/*************************
	 ********2D-Vector********
	 *************************/
	public tuple vec2( real x, real y )
			
	public function vec2.op_plus( vec2 v )	returns vec2
		return vec2(this.x + v.x, this.y + v.y)
	
	public function vec2.op_minus( vec2 v )	returns vec2
		return vec2(this.x - v.x, this.y - v.y)
		
	public function vec2.op_mult(real factor) returns vec2
		return vec2(this.x*factor, this.y*factor) 
		
	public function vec2.addReals( real x, real y )	returns vec2
		return vec2(this.x + x, this.y + y)
	
	public function vec2.toVec3() returns vec3
		return vec3( this.x, this.y, 0. )
		
	public function vec2.dot( vec2 v ) returns real
		return this.x*v.x+this.y*v.y
	
	public function vec2.norm() returns vec2
        real len = this.length()
        real x = 0 
        real y = 0
        if (len != 0.0)
            x = (this.x / len)
            y = (this.y / len)
        return vec2(x,y)
	
	public function vec2.trim( real value ) returns vec2
		vec2 result = this
		if result.x > -value and result.x < value
			result.x = 0.
		if this.y > -value and this.y < value
			result.y = 0.
		return result
		
	public function vec2.length() returns real
		return SquareRoot(this.x*this.x+this.y*this.y)
		
	public function vec2.lengthSquared() returns real
		return this.x*this.x+this.y*this.y
		
	public function vec2.inCircle( vec2 v2, real radius ) returns boolean
		if (this.x-v2.x).squared() + (this.y-v2.y).squared() <= radius*radius
			return true
		return false
		
	public function vec2.toString() returns string
		return "Vector2 [ " + this.x.toString() + ", " + this.y.toString() + " ]"
	
	public function unit.getPos() returns vec2
	 	return vec2(this.getX(), this.getY()) 
	 	
	public function vec2.angleTo(vec2 v) returns real
		return Atan2(v.y - this.y, v.x - this.x) 
		
	public function vec2.polarOffset(real angle, real dist) returns vec2
		return vec2(this.x + Cos(angle)*dist, this.y + Sin(angle)*dist)
		
	public function vec2.setLength( real length ) returns vec2
		real l = SquareRoot(this.x*this.x + this.y*this.y)
		if l == 0.0
			printError("vector.setLength error: The length of the vector is 0.0!")
			return vec2(0.,0.)
        l = length/l
        return vec2(this.x*l, this.y*l)
        
	public function vec2.withZ(real z) returns vec3
		return vec3(this.x, this.y, z) 
	
endpackage 
