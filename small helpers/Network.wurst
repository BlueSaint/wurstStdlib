package Network
import Thread

	/*
	*   How many ints to synchronize per instant
	*
	*   For efficiency reasons, should be a power of 2
	*   If you find that your threads are crashing due to too many operations, lower the burst size
	*
	*   Possible Burst Sizes (4096 = MAX)
	*	   1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096
	*/
constant int BURST_SIZE = 512


class Memory
	private static constant string KEY = "!#$%&()*+'-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`{}~"
	static constant int KEY_LENGTH = StringLength(KEY)
	static constant int KEY_LENGTH_2D = KEY_LENGTH*KEY_LENGTH
	
	private static string array keyStr
	private static gamecache array data
	
	static function write( int k1, int k2, int k3, int v )
		StoreInteger(data[k1], keyStr[k2], keyStr[k3], v)
		SyncStoredInteger(data[k1], keyStr[k2], keyStr[k3])
	
	static function read( int k1, int k2, int k3 ) returns int
		return GetStoredInteger(data[k1], keyStr[k2], keyStr[k3])
	
	static function flush( int k1, int k2, int k3 )
		FlushStoredInteger(data[k1], keyStr[k2], keyStr[k3])
	
	static function has( int k1, int k2, int k3 ) returns boolean
		return HaveStoredInteger(data[k1], keyStr[k2], keyStr[k3])
	
	static function flushKey( int k1 )
		FlushGameCache(data[k1])
		data[k1] = InitGameCache(keyStr[k1])
	
	
	static function writeB( int k1, int k2, int k3 )
		StoreBoolean(data[k1], keyStr[k2], keyStr[k3], true)
		SyncStoredBoolean(data[k1], keyStr[k2], keyStr[k3])
	
	static function hasB( int k1, int k2, int k3 ) returns boolean
		return HaveStoredBoolean(data[k1], keyStr[k2], keyStr[k3])
	
	
init
	for k = Memory.KEY_LENGTH downto 0
		Memory.keyStr[k] = SubString(Memory.KEY, k, k + 1)

	for k = Memory.KEY_LENGTH downto 0
		Memory.data[k] = InitGameCache(Memory.keyStr[k])


class Data   
	private static int instanceCount = 0
	private static int array recycler
	private static hashtable array data
	
	static function create() returns thistype
		var newD = recycler[0] castTo Data
		if (0 == newD castTo int)
			newD = (instanceCount + 1) castTo Data
			instanceCount = newD castTo int
		else
			recycler[0] = recycler[newD castTo int]
		
		return newD

	function destr()
		for i = 11 downto 0
			FlushChildHashtable(data[i], this castTo int)
	
	function read( int pid, int k ) returns int
		return LoadInteger(data[pid], this castTo int, k)

	function write( int pid, int k, int v )
		SaveInteger(data[pid], this castTo int, k, v)
	

init
	for i = 11 downto 0
		if (GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(i)) == MAP_CONTROL_USER)
			Data.data[i] = InitHashtable()


class BufferQueue
	private static int instanceCount = 0
	private static int array recycler
	thistype next
	thistype last
	
	int size
	
	function expand() returns boolean
		var newBQ = recycler[0]
			
		if (0 == newBQ)
			newBQ = BufferQueue.instanceCount + 1
			if (newBQ == Memory.KEY_LENGTH)
				return false

			instanceCount = newBQ
		else
			recycler[0] = recycler[newBQ]
			
			(newBQ castTo BufferQueue).next = null
			last.next = (newBQ castTo BufferQueue)
			last = (newBQ castTo BufferQueue)
			size = size + Memory.KEY_LENGTH_2D
			
		return true

		
	function contract()
		var first = next
		
		next = first.next
		
		recycler[first castTo int] = recycler[0]
		recycler[0] = first castTo int
		
		size = size - Memory.KEY_LENGTH_2D
		
		if (null == next)
			last = this

		
	static function create() returns thistype
		var newBQ = recycler[0]
		
		if (0 == newBQ)
			newBQ = instanceCount + 1
			if (newBQ == Memory.KEY_LENGTH_2D)
				while true
					if 0 != recycler[0]
						break
					TriggerSyncStart()
					TriggerSyncReady()
				
				newBQ = recycler[0]
				recycler[0] = recycler[newBQ]
			else
				instanceCount = newBQ

		else
			recycler[0] = recycler[newBQ]

		
		(newBQ castTo BufferQueue).next = null
		(newBQ castTo BufferQueue).last = (newBQ castTo BufferQueue)
		
		(newBQ castTo BufferQueue).size = Memory.KEY_LENGTH_2D
		
		return (newBQ castTo BufferQueue)

		
	function destr()
		var tmp = next
		while true
			recycler[this castTo int] = recycler[0]
			recycler[0] = this castTo int
			if null == tmp
				break
			tmp = tmp.next

class BufferKey
	private BufferQueue parent
	private static int instanceCount = 0
	private static int array recycler
	
	//key is split up into 3 sections
	int key1
	int key2
	int key3
	
	static function create( BufferQueue parent ) returns thistype
		var newBK = recycler[0]
		if (0 == newBK)
			newBK = instanceCount + 1
			instanceCount = newBK
		else
			recycler[0] = recycler[newBK]

			
		(newBK castTo BufferKey).parent = parent
		
		(newBK castTo BufferKey).key1 = parent castTo int
		
		return (newBK castTo BufferKey)

		
	function destr()
		recycler[this castTo int] = recycler[0]
		recycler[0] = this castTo int
	
		key2 = 0
		key3 = 0

	
	function reset()
		key1 = parent castTo int
		key2 = 0
		key3 = 0
	
	function expand( integer expansion )
		if (0 == key1)
			key1 = expansion

	
	function goNext() returns boolean
		key3 = key3 + 1
		if (key3 == Memory.KEY_LENGTH)
			key3 = 0
			key2 = key2 + 1
			if (key2 == Memory.KEY_LENGTH)
				key2 = 0
				key1 = (key1 castTo BufferQueue).next castTo int

		
		return 0 != key1

	
	function isEmpty() returns boolean
		return not Memory.has(key1, key2, key3)

	function write( integer v )
		Memory.write(key1, key2, key3, v)

	function read() returns integer
		return Memory.read(key1, key2, key3)



class Buffer
	private BufferKey writeKey
	private BufferKey progressKey
	private BufferKey dumpKey
	
	private function getQueue() returns BufferQueue
		return ((this castTo int) castTo BufferQueue)

	function getSize() returns int
		return getQueue().size
	
	function expand() returns boolean
		if (getQueue().expand())
			writeKey.expand(getQueue().last castTo int)
			return true
		
		return false

	
	function getProgress() returns int
		var progress = 0
		int k1 = 0
		int k2 = 0
		int k3 = 0
		
		//loop until empty buffer position or at buffer end
		for i = 0 to 2501
			progress++
			k1 = progressKey.key1
			k2 = progressKey.key2
			k3 = progressKey.key3
			if progressKey.isEmpty() or not progressKey.goNext()
				break

		
		if (0 == progressKey.key1)
			progressKey.key1 = k1
			progressKey.key2 = k2
			progressKey.key3 = k3
		
		return progress

	
	private function flush()
		var temp = this
		while temp != null
			Memory.flushKey(temp castTo int)
			temp = ((getQueue().next castTo int) castTo Buffer)

	//takes current position in memory (index) and returns new position
	function dump( Data data, int pid, int index, int remainingData, int end ) returns int
		int count = 0
		int idx = index
		//dump buffer to table
		while true
			data.write(pid, index, dumpKey.read())
			idx++
		
			dumpKey.goNext()
			if index == end
				break
			
			count = count + 1
			if (count - count/1500*1500 == 0)
				TriggerSyncStart()

		
		//flush buffer
		flush()
		
		//rekeys
		writeKey.reset()
		progressKey.reset()
		dumpKey.reset()
		
		//contract buffer
		while getQueue().size - Memory.KEY_LENGTH_2D >= remainingData
			getQueue().contract()
		
		return index
	
	function write( int v )returns boolean
		writeKey.write(v)
		return writeKey.goNext()

	static function create() returns thistype
		var newB = BufferQueue.create()
		
		((newB castTo int) castTo Buffer).writeKey = BufferKey.create(newB)
		((newB castTo int) castTo Buffer).progressKey = BufferKey.create(newB)
		((newB castTo int) castTo Buffer).dumpKey = BufferKey.create(newB)
		
		return ((newB castTo int) castTo Buffer)

	
	function destr()
		flush()
		getQueue().destr()
		writeKey.destr()
		progressKey.destr()
		dumpKey.destr()

public class Packet
	private static integer instanceCount = 0
	private static integer array recycler
	
	private static function allocate() returns thistype
		var newP = recycler[0]
		
		if (0 == newP)
			newP = instanceCount + 1
			if (newP == Memory.KEY_LENGTH)
				while true
					if 0 != recycler[0]
						break
					TriggerSyncStart()
					TriggerSyncReady()
				
				newP = recycler[0]
				recycler[0] = recycler[newP]
			else
				instanceCount = newP
		else
			recycler[0] = recycler[newP]
		
		return newP castTo Packet

	
	private function deallocate()
		recycler[this castTo int] = recycler[0]
		recycler[0] = this castTo int
	
	private function synchronize( integer data, boolean source )
		Thread thread = new Thread()
		integer syncPlayer = 11
		
		if (source)
			Memory.write(0, GetPlayerId(GetLocalPlayer()), this castTo int, data)
		else
			Memory.writeB(0, GetPlayerId(GetLocalPlayer()), this castTo int)
		
		while true
			if (-1 == syncPlayer)
				if thread.isSynced()
					break
			else if ((GetPlayerSlotState(Player(syncPlayer)) != PLAYER_SLOT_STATE_PLAYING 
					or GetPlayerController(Player(syncPlayer)) != MAP_CONTROL_USER) 
					or (Memory.has(0, syncPlayer, this castTo int) or Memory.hasB(0, syncPlayer, this castTo int)))
				syncPlayer = syncPlayer - 1
				if (-1 == syncPlayer)
					thread.sync()

			TriggerSyncReady()

		
		destroy thread

	
	private function flush()
		for i = 11 downto 0
			Memory.flush(0, i, this castTo int)

	
	static function broadcast( integer data, boolean source ) returns Packet
		var dis = allocate()
		dis.synchronize(data, source)
		
		return dis

	
	function get( integer playerId ) returns integer
		return Memory.read(0, playerId, this castTo int)

	function has( integer playerId ) returns boolean
		return Memory.has(0, playerId, this castTo int)
	
	function destr()
		flush()
		deallocate()


	//! runtextmacro STREAM()
