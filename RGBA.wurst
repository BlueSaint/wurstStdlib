package RGBA
//******************************************************************************
//*
//* ARGB 1.2
//*  ==  == 
//*  For your color needs.
//*  
//*  An ARGB object is a by-value struct, this means that assigning copies the
//* contents of the struct and that you don't have to use .destroy(), the
//* downside is that you cannot assign its members (can't do set c.r= 123 )
//*
//*  This library should have plenty of uses, for example, if your spell involves
//* some unit recoloring you can allow users to input the color in the config
//* section as 0xAARRGGBB and you can use this to decode that stuff.
//*
//* You can also easily merge two colors and make fading effects using ARGB.mix
//*
//* There's ARGB.fromPlayer which gets an ARGB object containing the player's
//* color. you can use the previous utilities on it.
//*
//* The .str() instance method can recolor a string, and the recolorUnit method
//* will apply the ARGB on a unit
//*
//* For other uses, you can use the .red, .green, .blue and .alpha members to get
//* an ARGB object's color value (from 0 to 255).
//*
//* structs that have a recolor method that takes red,green,blue and alpha as 0.255
//* integers can implement the ARGBrecolor module to gain an ability to quickly
//* recolor using an ARGB object.
//*
//********************************************************************************

// ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  == =
	
	//this double naming stuff is beginning to make me insane, if only TriggerEvaluate() wasn't so slow...
	public tuple color(int red, int green, int blue)
	public tuple colorRGBA(int red, int green, int blue, int alpha)
	
	public function color.withAlpha( int a ) returns colorRGBA
		return colorRGBA(this.red, this.green, this.blue, a)
		
	public function fromHexString( string number ) returns colorRGBA
		var alpha = number.substring(0,2)
		var red = number.substring(2,4)
		var green = number.substring(4,6)
		var blue = number.substring(6,4)
		
		return colorRGBA( toDec(red), toDec(green), toDec(blue), toDec(alpha) )
	
	public function makeColor(int colo) returns colorRGBA
		int a = 0
	    int r = 0
	    int g = 0
	    int b = 0
	    int col = colo
	    if col < 0
			col=-(-col+0x80000000)
			a = 0x80 + col div 0x1000000
			col = col-(a-0x80)*0x1000000
		else
			a = col div 0x1000000
			col = col-a*0x1000000
           
		r=col div 0x10000
		col=col-r*0x10000
		g=col div 0x100
		b=col-g*0x100

		return colorRGBA(r,g,b,a)
	    
    public function fromPlayerColor( playercolor pc ) returns color
        if pc  ==  PLAYER_COLOR_RED
            return color(255,3,3)
        else if pc == PLAYER_COLOR_BLUE
            return color(0,66,255)
        else if pc == PLAYER_COLOR_CYAN
            return color(28,230,185)
        else if pc == PLAYER_COLOR_PURPLE
            return color(84,0,129)
        else if pc == PLAYER_COLOR_YELLOW
            return color(255,252,1)
        else if pc == PLAYER_COLOR_ORANGE
            return color(254,138,14)
        else if pc == PLAYER_COLOR_GREEN
            return color(32,192,0)
        else if pc == PLAYER_COLOR_PINK
            return color(229,91,176)
        else if pc == PLAYER_COLOR_LIGHT_GRAY
            return color(149,150,151)
        else if pc == PLAYER_COLOR_LIGHT_BLUE
            return color(126,191,241)
        else if pc == PLAYER_COLOR_AQUA
            return color(16,98,70)
        else if pc == PLAYER_COLOR_BROWN
            return color(78,42,4)
        
        return color(0,0,0)
	    
	
    public function fromPlayer( player p ) returns color
		return fromPlayerColor(GetPlayerColor(p))
        

	
    // ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  == 
    // Mixes two colors, s would be a number 0<=s<=1 that determines
    // the weight given to color c2.
    //
    //  mix(c1,c2,0)   = c1
    //  mix(c1,c2,1)   = c2
    //  mix(c1,c2,0.5) = Mixing the colors c1 and c2 in equal proportions.
    //
    public function colorRGBA.mix( colorRGBA c2, real s ) returns colorRGBA
		return colorRGBA( R2I(c2.red*s+this.red*(1-s)+0.5),
						R2I(c2.green*s+this.green*(1-s)+0.5),
						R2I(c2.blue*s+this.blue*(1-s)+0.5), 						
						R2I(c2.alpha*s+this.alpha*(1-s)+0.5))

	
	public function colorRGBA.toString() returns string
		return "colorRBGA [" + this.red.toString() + "|" +this.green.toString() + "|" +this.blue.toString() + "|"+this.alpha.toString() +"]"

	
	public function unit.recolor( colorRGBA col )
		SetUnitVertexColor(this,col.red,col.green,col.blue,col.alpha)
		
	public function colorRGBA.toColorString() returns string
		return "|C" + toHex(this.alpha) + toHex(this.red) + toHex(this.green) + toHex(this.blue)

	public function toHex( int number ) returns string
		var firstpart = number div 16
		var secondpart = number - firstpart * 16
		return hexs[firstpart] + hexs[secondpart]
		
	public function toDec( string twochar ) returns int
		if twochar.length() > 2
			printError("todec is not made for this")
		
		var first = twochar.substring(0,1)
		var second = twochar.substring(1,2)
		
		return decs.loadInt(StringHash(first)) * 16 + decs.loadInt(StringHash(second))
	
	string array hexs
	Table decs
	
	init
		for i = 0 to 9
			hexs[i] = i.toString()
		hexs[10] = "A"
		hexs[11] = "B"
		hexs[12] = "C"
		hexs[13] = "D"
		hexs[14] = "E"
		hexs[15] = "F"
		
		decs = new Table()
		for i2 = 0 to 9
			decs.saveInt(StringHash(i2.toString()), i2 )
		
		decs.saveInt(StringHash("A"), 10 )
		decs.saveInt(StringHash("B"), 11 )
		decs.saveInt(StringHash("C"), 12 )
		decs.saveInt(StringHash("D"), 13 )
		decs.saveInt(StringHash("E"), 14 )
		decs.saveInt(StringHash("F"), 15 )
	

endpackage